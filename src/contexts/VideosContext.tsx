import React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';
import { Video } from '../types';
import { youtubeAPI } from '../services/youtubeAPI';
import { useAuth } from './AuthContext';
import { useFavorites } from './FavoritesContext';
import { db } from '../firebaseConfig';
import { 
  collection, 
  doc, 
  getDocs, 
  setDoc, 
  deleteDoc, 
  updateDoc, 
  onSnapshot,
  query,
  where 
} from 'firebase/firestore';

interface VideosContextType {
  videos: Video[];
  watchedVideoIds: string[];
  laterVideoIds: string[];
  isLoading: boolean;
  error: string | null;
  fetchLatestVideos: () => Promise<void>;
  markVideoWatched: (videoId: string) => void;
  markVideoLater: (videoId: string) => void;
  markVideoDeleted: (videoId: string) => void;
  removeVideoFromWatched: (videoId: string) => void;
  removeVideoFromLater: (videoId: string) => void;
  restoreVideoFromDeleted: (videoId: string) => void;
  clearError: () => void;
  // üÜï Helpers pour les vid√©os supprim√©es
  getDeletedVideos: () => Video[];
  getVisibleVideos: () => Video[];
}

const VideosContext = createContext<VideosContextType | undefined>(undefined);

export const VideosProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { currentUser } = useAuth();
  const { favorites } = useFavorites();
  const [videos, setVideos] = useState<Video[]>([]);
  const [watchedVideoIds, setWatchedVideoIds] = useState<string[]>([]);
  const [laterVideoIds, setLaterVideoIds] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const clearError = useCallback(() => setError(null), []);

  // M√©moisation des cl√©s localStorage pour compatibilit√© (√©tats utilisateur)
  const storageKeys = useMemo(() => {
    if (!currentUser) return null;
    return {
      watched: `watchedVideos_${currentUser.uid}`,
      later: `laterVideos_${currentUser.uid}`,
    };
  }, [currentUser]);

  // Charger les √©tats "watched" et "later" depuis localStorage (compatibilit√©)
  useEffect(() => {
    if (!currentUser || !storageKeys) {
      setWatchedVideoIds([]);
      setLaterVideoIds([]);
      return;
    }
    
    const watched = localStorage.getItem(storageKeys.watched);
    const later = localStorage.getItem(storageKeys.later);
    
    setWatchedVideoIds(watched ? JSON.parse(watched) : []);
    setLaterVideoIds(later ? JSON.parse(later) : []);
  }, [currentUser, storageKeys]);

  // Sauvegarder les √©tats "watched" et "later" dans localStorage
  useEffect(() => {
    if (!currentUser || !storageKeys) return;
    localStorage.setItem(storageKeys.watched, JSON.stringify(watchedVideoIds));
  }, [watchedVideoIds, currentUser, storageKeys]);

  useEffect(() => {
    if (!currentUser || !storageKeys) return;
    localStorage.setItem(storageKeys.later, JSON.stringify(laterVideoIds));
  }, [laterVideoIds, currentUser, storageKeys]);

  // üÜï Charger les vid√©os depuis Firestore avec listener temps r√©el
  useEffect(() => {
    if (!currentUser) {
      setVideos([]);
      return;
    }

    console.log(`[VideosContext] üî• Setting up Firestore listener for user ${currentUser.uid}`);
    
    const videosRef = collection(db, 'videos', currentUser.uid, 'userVideos');
    const unsubscribe = onSnapshot(videosRef, (snapshot) => {
      try {
        const videosData = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
        })) as Video[];
        
        console.log(`[VideosContext] üì± ${videosData.length} vid√©os charg√©es depuis Firestore`);
        
        // Debug: afficher les vid√©os supprim√©es
        const deletedVideos = videosData.filter(v => v.is_deleted);
        if (deletedVideos.length > 0) {
          console.log(`[VideosContext] üóëÔ∏è ${deletedVideos.length} vid√©os supprim√©es trouv√©es:`, 
            deletedVideos.map(v => ({ id: v.id, title: v.title, channelId: v.channelId })));
        }
        
        setVideos(videosData);
      } catch (error) {
        console.error('[VideosContext] Erreur lors du chargement des vid√©os Firestore:', error);
        setError('Erreur lors du chargement des vid√©os');
      }
    }, (error) => {
      console.error('[VideosContext] Erreur listener Firestore:', error);
      setError('Erreur de synchronisation des vid√©os');
    });

    return unsubscribe;
  }, [currentUser]);

  // üÜï Sauvegarder une vid√©o dans Firestore
  const saveVideoToFirestore = useCallback(async (video: Video) => {
    if (!currentUser) return;
    
    try {
      const videoRef = doc(db, 'videos', currentUser.uid, 'userVideos', video.id);
      await setDoc(videoRef, video, { merge: true });
      console.log(`[VideosContext] üíæ Vid√©o "${video.title}" sauvegard√©e dans Firestore`);
    } catch (error) {
      console.error(`[VideosContext] Erreur lors de la sauvegarde de la vid√©o ${video.id}:`, error);
      throw error;
    }
  }, [currentUser]);

  // üÜï Supprimer une vid√©o de Firestore
  const deleteVideoFromFirestore = useCallback(async (videoId: string) => {
    if (!currentUser) return;
    
    try {
      const videoRef = doc(db, 'videos', currentUser.uid, 'userVideos', videoId);
      await deleteDoc(videoRef);
      console.log(`[VideosContext] üóëÔ∏è Vid√©o ${videoId} supprim√©e de Firestore`);
    } catch (error) {
      console.error(`[VideosContext] Erreur lors de la suppression de la vid√©o ${videoId}:`, error);
      throw error;
    }
  }, [currentUser]);

  const markVideoWatched = useCallback((videoId: string) => {
    setWatchedVideoIds((prev) => prev.includes(videoId) ? prev : [...prev, videoId]);
    setLaterVideoIds((prev) => prev.filter(id => id !== videoId));
    
    // üÜï Marquer comme non supprim√©e dans Firestore si elle existait
    const video = videos.find(v => v.id === videoId);
    if (video && video.is_deleted) {
      const updatedVideo = { ...video, is_deleted: false };
      saveVideoToFirestore(updatedVideo);
    }
  }, [videos, saveVideoToFirestore]);

  const markVideoLater = useCallback((videoId: string) => {
    setLaterVideoIds((prev) => prev.includes(videoId) ? prev : [...prev, videoId]);
    setWatchedVideoIds((prev) => prev.filter(id => id !== videoId));
    
    // üÜï Marquer comme non supprim√©e dans Firestore si elle existait
    const video = videos.find(v => v.id === videoId);
    if (video && video.is_deleted) {
      const updatedVideo = { ...video, is_deleted: false };
      saveVideoToFirestore(updatedVideo);
    }
  }, [videos, saveVideoToFirestore]);

  const markVideoDeleted = useCallback(async (videoId: string) => {
    console.log('[VideosContext] üóëÔ∏è Marquage vid√©o comme supprim√©e:', videoId);
    
    setWatchedVideoIds((prev) => prev.filter(id => id !== videoId));
    setLaterVideoIds((prev) => prev.filter(id => id !== videoId));
    
    // üÜï Marquer comme supprim√©e dans Firestore
    const video = videos.find(v => v.id === videoId);
    if (video) {
      try {
        const updatedVideo = { ...video, is_deleted: true };
        await saveVideoToFirestore(updatedVideo);
        console.log(`[VideosContext] ‚úÖ Vid√©o ${videoId} marqu√©e comme supprim√©e dans Firestore`);
      } catch (error) {
        console.error(`[VideosContext] Erreur lors de la suppression de ${videoId}:`, error);
        setError('Erreur lors de la suppression de la vid√©o');
      }
    }
  }, [videos, saveVideoToFirestore]);

  const removeVideoFromWatched = useCallback((videoId: string) => {
    setWatchedVideoIds((prev) => prev.filter(id => id !== videoId));
  }, []);

  const removeVideoFromLater = useCallback((videoId: string) => {
    setLaterVideoIds((prev) => prev.filter(id => id !== videoId));
  }, []);

  const restoreVideoFromDeleted = useCallback(async (videoId: string) => {
    console.log('[VideosContext] üîÑ Restauration de la vid√©o supprim√©e:', videoId);
    
    // üÜï Restaurer dans Firestore
    const video = videos.find(v => v.id === videoId);
    if (video) {
      try {
        const updatedVideo = { ...video, is_deleted: false };
        await saveVideoToFirestore(updatedVideo);
        console.log(`[VideosContext] ‚úÖ Vid√©o ${videoId} restaur√©e dans Firestore`);
      } catch (error) {
        console.error(`[VideosContext] Erreur lors de la restauration de ${videoId}:`, error);
        setError('Erreur lors de la restauration de la vid√©o');
      }
    }
  }, [videos, saveVideoToFirestore]);

  // üÜï Helper pour obtenir les vid√©os supprim√©es
  const getDeletedVideos = useCallback(() => {
    return videos.filter(video => video.is_deleted);
  }, [videos]);

  // üÜï Helper pour obtenir les vid√©os visibles (non supprim√©es)
  const getVisibleVideos = useCallback(() => {
    return videos.filter(video => !video.is_deleted);
  }, [videos]);

  const fetchLatestVideos = useCallback(async () => {
    if (!currentUser) {
      setVideos([]);
      setIsLoading(false);
      return;
    }
    
    if (favorites.length === 0) {
      setVideos([]);
      setIsLoading(false);
      console.log("[VideosContext] No favorites to fetch videos for.");
      return;
    }
    
    setIsLoading(true);
    setError(null);
    console.info(`[VideosContext] üöÄ Fetching latest videos for ${favorites.length} favorite(s) of user ${currentUser.uid}.`);
    
    try {
      const channelIds = favorites.map(channel => channel.id);
      const latestVideos = await youtubeAPI.getLatestVideos(channelIds);
      
      // üÜï LOGIQUE INTELLIGENTE DE COMPARAISON AVEC FIRESTORE
      for (const newVideo of latestVideos) {
        // Ajouter la thumbnail de la cha√Æne
        const videoWithThumbnail = {
          ...newVideo,
          channelThumbnail: favorites.find(f => f.id === newVideo.channelId)?.thumbnail || '',
          is_deleted: false, // Par d√©faut, nouvelle vid√©o = visible
        };
        
        // Chercher si cette EXACTE vid√©o (m√™me ID) existe d√©j√† dans Firestore
        const existingVideo = videos.find(v => v.id === newVideo.id);
        
        if (existingVideo) {
          // üéØ M√äME VID√âO TROUV√âE
          if (existingVideo.is_deleted) {
            console.log(`[VideosContext] üóëÔ∏è Vid√©o "${newVideo.title}" (ID: ${newVideo.id}) toujours supprim√©e, ne pas afficher`);
            // Ne rien faire - la vid√©o reste supprim√©e
          } else {
            console.log(`[VideosContext] ‚úÖ Vid√©o "${newVideo.title}" (ID: ${newVideo.id}) d√©j√† en base et visible`);
            // Mettre √† jour les m√©tadonn√©es si n√©cessaire
            await saveVideoToFirestore(videoWithThumbnail);
          }
        } else {
          // üéØ NOUVELLE VID√âO (ID diff√©rent)
          
          // V√©rifier s'il y a une vid√©o supprim√©e de cette cha√Æne
          const deletedVideoFromChannel = videos.find(
            v => v.channelId === newVideo.channelId && v.is_deleted
          );
          
          if (deletedVideoFromChannel) {
            console.log(`[VideosContext] üîÑ NOUVELLE vid√©o "${newVideo.title}" (ID: ${newVideo.id}) d√©tect√©e pour ${newVideo.channelTitle}. ` +
              `Remplace l'ancienne vid√©o supprim√©e "${deletedVideoFromChannel.title}" (ID: ${deletedVideoFromChannel.id}) ‚Üí RESTAURATION AUTOMATIQUE`);
            
            // Supprimer l'ancienne vid√©o supprim√©e de Firestore
            await deleteVideoFromFirestore(deletedVideoFromChannel.id);
          } else {
            console.log(`[VideosContext] üÜï Nouvelle vid√©o "${newVideo.title}" (ID: ${newVideo.id}) pour ${newVideo.channelTitle}`);
          }
          
          // Sauvegarder la nouvelle vid√©o (visible par d√©faut)
          await saveVideoToFirestore(videoWithThumbnail);
        }
      }
      
      console.log(`[VideosContext] ‚úÖ Traitement termin√© pour ${latestVideos.length} vid√©os`);
    } catch (error: any) {
      console.error(`[VideosContext] Error fetching latest videos for user ${currentUser.uid}:`, error.message || error);
      setError(error.message || 'Failed to fetch latest videos');
    } finally {
      setIsLoading(false);
    }
  }, [currentUser, favorites, videos, saveVideoToFirestore, deleteVideoFromFirestore]);

  // R√©cup√©rer les vid√©os lorsque les favoris changent
  useEffect(() => {
    if (currentUser && favorites.length > 0) {
      console.log("[VideosContext] Favorites changed or user changed, fetching latest videos.");
      fetchLatestVideos();
    }
  }, [currentUser, favorites, fetchLatestVideos]);

  // M√©moisation de la valeur du contexte pour √©viter les re-renders inutiles
  const contextValue = useMemo(() => ({
    videos,
    watchedVideoIds,
    laterVideoIds,
    isLoading,
    error,
    fetchLatestVideos,
    markVideoWatched,
    markVideoLater,
    markVideoDeleted,
    removeVideoFromWatched,
    removeVideoFromLater,
    restoreVideoFromDeleted,
    clearError,
    getDeletedVideos,
    getVisibleVideos,
  }), [
    videos,
    watchedVideoIds,
    laterVideoIds,
    isLoading,
    error,
    fetchLatestVideos,
    markVideoWatched,
    markVideoLater,
    markVideoDeleted,
    removeVideoFromWatched,
    removeVideoFromLater,
    restoreVideoFromDeleted,
    clearError,
    getDeletedVideos,
    getVisibleVideos,
  ]);

  return (
    <VideosContext.Provider value={contextValue}>
      {children}
    </VideosContext.Provider>
  );
};

export const useVideos = (): VideosContextType => {
  const context = useContext(VideosContext);
  if (context === undefined) {
    throw new Error('useVideos must be used within a VideosProvider');
  }
  return context;
}; 